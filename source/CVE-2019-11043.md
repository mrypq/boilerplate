---
title: CVE-2019-11043
date: 2019-01-10
tags: ["Vuln", "Security"]
excerpt:CVE-2019-11043の検証 
---

## 概要
NginxとPHP-FPMで構成される環境において、特定の設定値が設定されている場合にリモートからの任意コード実行が可能となる脆弱性です。  
Nginxが以下の設定を満たす場合、任意コードの実行が可能になります。

- locationディレクティブでリクエストをPHP-FPMに転送するようになっている
- PATH_INFO変数を割り当てる際にfastcgi_paramディレクティブが使用されている
- fastcgi_split_path_infoディレクティブが存在し、「^」で始まり「$」で終わる正規表現が用いられている
- `try_files $uri =404`のようなファイルの有無を判断するためのチェックがない

具体的には、Nginxのconfigが以下のようであり、php-fpmにリクエストを転送している場合にこの脆弱性の影響を受ける可能性があります。
```
location ~ [^/]\.php(/|$) {
     fastcgi_split_path_info ^(.+?\.php)(/.*)$;
     fastcgi_param PATH_INFO $fastcgi_path_info;
     fastcgi_pass php:9000;
     ...
}
```
この設定はNginxのかなり標準的な設定であり、この脆弱性の影響が広範囲に及んでいる可能性があります。

## 環境
この脆弱性の影響を受けるバージョンは以下の通りです。

- PHP7.1系：〜7.1.32  
- PHP7.2系：〜7.2.23  
- PHP7.3系：〜7.3.10  

## 攻撃手順
https://github.com/neex/phuip-fpizdam  
こちらのPoCの攻撃手順です。

### 1. PHP-FPMに新しいバッファーを割り当てる

PHP-FPMでは、CGI環境は構造体`fcgi_data_seg`に格納され、構造体`fcgi_hash`によって管理されます。  
バッファーの現在位置である`fcgi_data_seg->pos`が終端`fcgi_data_seg->end`まで進んだ時、PHP-FPMには新しいバッファーが割り振られ、それまでのバッファーは`fcgi_data_seg->next`に移動されます。

URLに大量のクエリ文字列を付与し、`fcgi_data_seg`を`fcgi_data_seg->end`まで進めて新しいバッファーを確保します。

こうすることにより、`path_info`から`fcgi_data_seg->pos`へのオフセットが34だとわかります。


### 2. path_infoのアドレスをfcgi_data_seg->posと一致させる

概要で述べた設定のNginxにおいて、URLに改行コード`%0A`が含まれる場合、`path_info`という変数が空の状態でPHP側に渡されます。  
これと`sapi/fpm/fpm/fpm_main.c`におけるバッファーアンダーフローの脆弱性を利用し、`path_info`を`fcgi_data_seg->pos`と一致させます。  

```c
// fpm_main.c
int ptlen = strlen(pt);
int slen = len - ptlen;
int pilen = env_path_info ? strlen(env_path_info) : 0;
int tflag = 0;
char *path_info;
if (apache_was_here) {
    /* recall that PATH_INFO won't exist */
    path_info = script_path_translated + ptlen;
    tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
} else {
    path_info = env_path_info ? env_path_info + pilen - slen : NULL;
    tflag = (orig_path_info != path_info);
}
```
ここで使う主要な変数は以下の通りです。  

- 変数`pilen`：path_infoの長さ（つまりpath_infoが空の時は０）  
- 変数`env_path_info`：path_infoのアドレス  
- 変数`slen`：URLのリクエスト部分の長さ（例：http://127.0.0.1:8080/script.php/test だとすると、[test]部分の長さ）
  
この時、`path_info = env_path_info ? env_path_info + pilen - slen : NULL;`の部分でバッファーアンダーフローが発生します。  
`slen`が34になるようにクエリ文字列を付与することで、`path_info`が`fcgi_data_seg->pos`と一致します。

### 3. Nullバイト書き込みを行い、バッファーを上書きする

`path_info`にNullバイト書き込みをします。  

```c
// fpm_main.c
path_info[0] = 0;
```
これにより`fcgi_data_seg->pos`のアドレスも変更されます。
末尾のアドレスに`00`を書き込んだため、`fcgi_data_seg->pos`は現在のバッファーの中央付近にシフトされ、新たな環境変数を追記した際にバッファーが上書きされます。　　

```c
// fpm_main.c
old = path_info[0];
   path_info[0] = 0;
   if (!orig_script_name ||
       strcmp(orig_script_name, env_path_info) != 0) {
       if (orig_script_name) {
           FCGI_PUTENV(request, "ORIG_SCRIPT_NAME", orig_script_name);
       }
       SG(request_info).request_uri = FCGI_PUTENV(request, "SCRIPT_NAME", env_path_info);
   } else {
       SG(request_info).request_uri = orig_script_name;
   }
   path_info[0] = old;
```
この部分で新たな環境変数`ORIG_SCRIPT_NAME`を上書きできるようになりました。

### 4. リモートコード実行を可能にする
環境変数を上書きしただけではリモートコードの実行はできません。  
PHP-FPMは環境変数を構造体`fcgi_hash_bucket`に保存しています。  
この時、PHP-FPMはハッシュテーブルを使用して管理を行っていて、まずハッシュテーブルから環境を取得し、その後`hash_value`、`var_len`、および内容を確認します。   

``` c
// fastcgi.c
static char *fcgi_hash_get(fcgi_hash *h, unsigned int hash_value, char *var, unsigned int var_len, unsigned int *val_len)
{
   unsigned int      idx = hash_value & FCGI_HASH_TABLE_MASK;
   fcgi_hash_bucket *p = h->hash_table[idx];

   while (p != NULL) {
      if (p->hash_value == hash_value &&
          p->var_len == var_len &&
          memcmp(p->var, var, var_len) == 0) {
          *val_len = p->val_len;
          return p->val;
      }
      p = p->next;
   }
   return NULL;
}
```

PHP-FPMのハッシュ生成アルゴリズムは非常に単純であり、以下のようになっています。  

```c
// fastcgi.c
#define FCGI_HASH_FUNC(var, var_len) \
   (UNEXPECTED(var_len < 3) ? (unsigned int)var_len : \
      (((unsigned int)var[3]) << 2) + \
      (((unsigned int)var[var_len-2]) << 4) + \
      (((unsigned int)var[var_len-1]) << 2) + \
      var_len)
```

つまり、`HTTP_EBUT`というヘッダーを用意すれば、`PHP_VALUE`とハッシュが衝突します。  
この状態でHTTPリクエストを送信すると、`PHP_VALUE`の代わりに`HTTP_EBUT`がハッシュテーブルから参照されます。

さらに、以下の関数で`HTTP_EBUT`のvalueを書き換えることによって、任意のコードを実行できるようになります。  

```c
// fpm_main.c
FCGI_PUTENV(request, "ORIG_SCRIPT_NAME", orig_script_name);
```

## 検証
上述のPoCで検証を行います。
まずはNginx+PHP-FPMでローカルに環境を作ります。

[f:id:mrypq:20200109112622p:plain:w400]
```
go get github.com/neex/phuip-fpizdam
```
で`phuip-fpizdam`コマンドを入手し、先ほど建てたローカル環境に対してコマンドを叩くと、任意のPHPコードが実行できる状態になります。
```
phuip-fpizdam http://127.0.0.1:8080/script.php
```
[f:id:mrypq:20200109112645p:plain:w400]

うまく動かない時は、数回試行することで実行できる可能性があります。

## 参考URL

- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11043  
- https://bugs.php.net/bug.php?id=78599
- https://github.com/neex/phuip-fpizdam　
- https://github.com/php/php-src/commit/ab061f95ca966731b1c84cf5b7b20155c0a1c06a#diff-624bdd47ab6847d777e15327976a9227
- https://paper.seebug.org/1063/
- https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html
- https://medium.com/@moniik/nginx-php-fpm%E3%81%AE%E8%84%86%E5%BC%B1%E6%80%A7-cve-2019-11043-%E3%82%92%E8%A6%8B%E3%81%A6%E3%81%BF%E3%82%8B-2006bb22f7bb

